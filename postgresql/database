--
-- PostgreSQL database dump
--

-- Dumped from database version 9.5.6
-- Dumped by pg_dump version 9.5.6

SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET search_path = public, pg_catalog;

--
-- Name: meter_reading_usage_rescale(integer, integer, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION meter_reading_usage_rescale(base_meter integer, meter integer, start_ts timestamp with time zone, stop_ts timestamp with time zone) RETURNS numeric
    LANGUAGE plpgsql STABLE STRICT
    AS $$DECLARE
base_prev_value numeric;
base_next_value numeric;
base_prev_ts timestamp with time zone;
base_next_ts timestamp with time zone;
prev_value numeric;
next_value numeric;
start_value numeric;
stop_value numeric;
scale numeric;
BEGIN
stop_value := meter_reading_value(meter, stop_ts);
IF stop_value IS NULL THEN RAISE NOTICE 'No stop reading for meter'; RETURN 0; END IF;
start_value := meter_reading_value(meter, start_ts);
IF start_value IS NULL THEN
start_value := meter_reading_value(meter, next_reading_ts(meter, start_ts));
END IF;
IF start_value IS NULL THEN RAISE NOTICE 'No start reading for meter'; RETURN 0; END IF;

IF stop_value < start_value THEN start_value := start_value + meter_wrap_value(meter); END IF;

RAISE DEBUG 'Period start: %', start_value;
RAISE DEBUG 'Period stop: %', stop_value;
RAISE DEBUG 'Period usage: %', (stop_value - start_value);

IF stop_value < start_value THEN RAISE NOTICE 'Unresolved wrap on meter'; RETURN NULL; END IF;

base_next_value := next_reading_value(base_meter, stop_ts);
base_next_ts := next_reading_ts(base_meter, stop_ts);
IF base_next_value IS NULL THEN
base_next_value := prev_reading_value(base_meter, stop_ts);
base_next_ts := prev_reading_ts(base_meter, stop_ts);
END IF;
IF base_next_value IS NULL THEN RAISE DEBUG 'No next reading for base meter'; END IF;

base_prev_value := prev_reading_value(base_meter, base_next_ts - '00:00:01'::interval);
base_prev_ts := prev_reading_ts(base_meter, base_next_ts - '00:00:01'::interval);
IF base_prev_value IS NULL THEN RAISE DEBUG 'No previous reading for base meter'; END IF;

IF base_prev_value = base_next_value THEN
base_prev_value := NULL;
base_next_value := NULL;
RAISE DEBUG 'Not enough readings for base meter';
END IF;

IF base_prev_value IS NULL OR base_next_value IS NULL THEN
prev_value := NULL;
next_value := NULL;
scale := 1;
ELSE
IF base_next_value < base_prev_value THEN base_next_value := base_next_value + meter_wrap_value(base_meter); END IF;

RAISE DEBUG 'Base meter previous: % at %', base_prev_value, base_prev_ts;
RAISE DEBUG 'Base meter next: % at %', base_next_value, base_next_ts;
RAISE DEBUG 'Base meter usage: %', (base_next_value - base_prev_value);

IF base_next_value < base_prev_value THEN RAISE NOTICE 'Unresolved wrap on base meter'; RETURN NULL; END IF;

prev_value := meter_reading_value(meter, base_prev_ts);
IF prev_value IS NULL THEN RAISE DEBUG 'No previous reading for meter'; END IF;

next_value := meter_reading_value(meter, base_next_ts);
IF next_value IS NULL THEN RAISE DEBUG 'No next reading for meter'; END IF;

IF next_value < prev_value THEN next_value := next_value + meter_wrap_value(meter); END IF;

RAISE DEBUG 'Meter previous: %', prev_value;
RAISE DEBUG 'Meter next: %', next_value;
RAISE DEBUG 'Meter usage: %', (next_value - prev_value);

IF next_value < prev_value THEN RAISE NOTICE 'Unresolved wrap on meter'; RETURN NULL; END IF;

IF next_value IS NOT NULL and prev_value IS NOT NULL THEN
scale := (base_next_value - base_prev_value)/(next_value - prev_value);


END IF;
END IF;

RAISE DEBUG 'Scale: %', scale;

RETURN ((stop_value - start_value) * scale)::numeric(9, 3);
END;$$;


--
-- Name: meter_reading_value(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION meter_reading_value(meter integer, ts timestamp with time zone) RETURNS numeric
    LANGUAGE plpgsql STABLE STRICT
    AS $$DECLARE
prev_value numeric;
next_value numeric;
prev_ts timestamp with time zone;
next_ts timestamp with time zone;
BEGIN
prev_value := prev_reading_value(meter, ts);
IF prev_value IS NULL THEN RETURN NULL; END IF;

next_value := next_reading_value(meter, ts);
IF next_value IS NULL OR prev_value = next_value THEN RETURN prev_value; END IF;

IF next_value < prev_value THEN next_value := next_value + meter_wrap_value(meter); END IF;
IF next_value < prev_value THEN RETURN NULL; END IF;

prev_ts := prev_reading_ts(meter, ts);
next_ts := next_reading_ts(meter, ts);
RETURN (prev_value + (next_value - prev_value) * (date_part('epoch', (ts - prev_ts))/date_part('epoch', (next_ts - prev_ts))));
END;$$;


--
-- Name: meter_wrap_value(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION meter_wrap_value(meter integer) RETURNS numeric
    LANGUAGE sql STABLE STRICT
    AS $_$SELECT 10^(major_digits)::numeric FROM meters WHERE id = $1;$_$;


--
-- Name: next_reading_ts(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION next_reading_ts(meter integer, after timestamp with time zone) RETURNS timestamp with time zone
    LANGUAGE sql STABLE STRICT
    AS $_$SELECT ts FROM readings WHERE meter = $1 AND ts >= $2 ORDER BY ts LIMIT 1;$_$;


--
-- Name: next_reading_value(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION next_reading_value(meter integer, after timestamp with time zone) RETURNS numeric
    LANGUAGE sql STABLE STRICT
    AS $_$SELECT value FROM readings WHERE meter = $1 and ts >= $2 ORDER BY ts LIMIT 1;$_$;


--
-- Name: prev_reading_ts(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION prev_reading_ts(meter integer, before timestamp with time zone) RETURNS timestamp with time zone
    LANGUAGE sql STABLE STRICT
    AS $_$SELECT ts FROM readings WHERE meter = $1 AND ts <= $2 ORDER BY ts DESC LIMIT 1;$_$;


--
-- Name: prev_reading_value(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION prev_reading_value(meter integer, before timestamp with time zone) RETURNS numeric
    LANGUAGE sql STABLE STRICT
    AS $_$SELECT value FROM readings WHERE meter = $1 and ts <= $2 ORDER BY ts DESC LIMIT 1;$_$;


SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: meters; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE meters (
    id integer NOT NULL,
    name text NOT NULL,
    major_digits integer NOT NULL,
    minor_digits integer NOT NULL
);


--
-- Name: meters_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE meters_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: meters_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE meters_id_seq OWNED BY meters.id;


--
-- Name: readings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE readings (
    meter integer NOT NULL,
    ts timestamp with time zone DEFAULT now() NOT NULL,
    value numeric(9,3)
);


--
-- Name: id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY meters ALTER COLUMN id SET DEFAULT nextval('meters_id_seq'::regclass);


--
-- Name: meters_name_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY meters
    ADD CONSTRAINT meters_name_key UNIQUE (name);


--
-- Name: meters_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY meters
    ADD CONSTRAINT meters_pkey PRIMARY KEY (id);


--
-- Name: readings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY readings
    ADD CONSTRAINT readings_pkey PRIMARY KEY (meter, ts);


--
-- PostgreSQL database dump complete
--

